Here’s a copy-paste “Replit Agent” prompt to hunt down the Slack “dispatch_failed” and fix it. It’s safe (no token dumps) and reversible.

⸻

Prompt for Replit Agent

Goal: Diagnose and fix Slack slash command failures showing “dispatch_failed”. Ensure /api/slack/commands reliably returns 200 JSON within 3s on production domain https://proofpoll.replit.app.

Do this in order:
	1.	Confirm production wiring

	•	Show me the current deploy config:
	•	Build command
	•	Start command
	•	HTTP port
	•	Health check path
	•	Verify that the app is serving on the production port and domain:
	•	curl -sS https://proofpoll.replit.app/api/health -w "\nHTTP: %{http_code}\n"
	•	curl -sS http://localhost:5001/api/health -w "\nHTTP: %{http_code}\n"

	2.	Verify Slack Request URL and reachability

	•	Print the exact value we’re expecting Slack to call:
	•	echo "Expected Slack Request URL: https://proofpoll.replit.app/api/slack/commands"
	•	Hit it without Slack signature to confirm the route is alive (should be 401 invalid signature, which proves reachability):
	•	curl -sS -X POST https://proofpoll.replit.app/api/slack/commands -H "Content-Type: application/x-www-form-urlencoded" -d "text=test" -w "\nHTTP: %{http_code}\n"

	3.	Add safe debug logging + fast ACK path

	•	Open app/api/slack/commands/route.ts and wrap verification/logic with safe structured logs (method, content-type, body length), but never log secrets or full payload.
	•	Add a guard to ACK within 1.5s even if downstream work is slower. If we don’t already do it, reply immediately with an ephemeral JSON:

// Return within 3s:
return NextResponse.json({ response_type: 'ephemeral', text: 'Creating poll…' })

Then any slow work (parsing, posting the interactive message) should be done via response_url or a follow-up fetch.

	4.	Temporary debug switch (auto-revert at the end)

	•	Respect process.env.DEBUG_SLACK === '1':
	•	When ON: log method, headers['content-type'], body size, and timestamps before and after verify.
	•	Keep signature verification ON; only extra logs.
	•	Create a .env.local entry (or use Replit env) DEBUG_SLACK=1 for a short test window.

	5.	Latency & 3s window checks

	•	Instrument the route to log t_start, t_verify_done, t_response_sent (in ms). Ensure total < 2500ms.
	•	Rebuild and start prod server on port 5001:
	•	npm run build
	•	npm run start (or whatever the deployment uses)

	6.	Live test from Slack

	•	From Slack, run: /poll "Ship next?" | Yes | No
	•	Immediately tail the logs and show:
	•	receipt time
	•	verify pass/fail
	•	response time and status
	•	If Slack still shows “dispatch_failed”, copy the timestamp and correlate with server logs (look for no hit vs. 4xx/5xx vs. slow >3s).

	7.	Common misconfig quick checks

	•	Confirm Request URL in Slack’s app settings is exact:
https://proofpoll.replit.app/api/slack/commands (no trailing slash, no http).
	•	Confirm scopes present: commands, chat:write.
	•	Confirm the app is installed in that workspace/channel.
	•	Confirm server returns:
	•	HTTP 200
	•	Content-Type: application/json
	•	JSON body like { "response_type": "in_channel", "text": "…" } or "ephemeral".

	8.	If we need to post the rich poll after the fast ACK

	•	Use the incoming payload’s response_url to POST the full interactive message once parsing is done.
	•	Ensure any fetch(response_url, …) includes Content-Type: application/json and is not awaited before sending the initial ACK.

	9.	Report back

	•	Paste:
	•	Replit deploy settings summary
	•	Results of health checks
	•	Results of step (2) “401 proves reachability”
	•	Log excerpt around one failing slash command (timestamps + durations)
	•	Final fix you applied (fast ACK, response_url follow-up, config correction, etc.)
	•	Turn off DEBUG_SLACK and remove the extra logs if not needed.

Success criteria
	•	Hitting /poll … in Slack no longer shows “dispatch_failed”.
	•	Server logs show request received, signature verified, and response sent in < 1500ms.
	•	Slack shows an ephemeral “Creating poll…” immediately, followed by the full poll message.

⸻

If anything blocks (e.g., build errors), fix and continue—don’t stop at the first issue.